// export.js - Génération du package d'installation

const Export = {
    // Générer le package complet
    async generatePackage(config) {
        try {
            // Créer un blob pour le ZIP
            const zip = new JSZip();
            
            // Ajouter les fichiers Python
            zip.file('__init__.py', this.generateInitFile());
            zip.file('APC_Mini_Custom.py', this.generateMainScript(config));
            
            // Ajouter le README
            zip.file('README.txt', this.generateReadme());
            
            // Ajouter un guide de mapping des pads
            zip.file('MAPPING_GUIDE.txt', this.generateMappingGuide(config));
            
            // Générer le ZIP
            const content = await zip.generateAsync({type: 'blob'});
            
            // Télécharger
            this.downloadFile(content, 'APC_Mini_Custom.zip');
            
            return true;
        } catch (error) {
            console.error('Erreur lors de la génération:', error);
            throw error;
        }
    },
    
    // Générer le fichier __init__.py
    generateInitFile() {
        return `# APC Mini MK1 Custom Script
# Generated by APC Mini Configurator

from .APC_Mini_Custom import APC_Mini_Custom

__all__ = ['APC_Mini_Custom']
`;
    },
    
    // Générer le script principal
    generateMainScript(config) {
        const buttonFunctions = {
            'play_stop': `
    def _setup_play_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        self._transport.set_play_button(button)`,
            
            'session_record': `
    def _setup_record_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        self._transport.set_record_button(button)`,
            
            'overdub': `
    def _setup_overdub_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        self._transport.set_overdub_button(button)`,
            
            'stop_all_clips': `
    def _setup_stop_all_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        self._transport.set_stop_button(button)`,
            
            'tap_tempo': `
    def _setup_tap_tempo_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        self._transport.set_tap_tempo_button(button)`,
            
            'metronome': `
    def _setup_metronome_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        self._transport.set_metronome_button(button)`,
            
            'undo': `
    def _setup_undo_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(lambda value: value and self.song().can_undo and self.song().undo())`,
            
            'redo': `
    def _setup_redo_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(lambda value: value and self.song().can_redo and self.song().redo())`,
            
            'capture_midi': `
    def _setup_capture_midi_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(lambda value: value and self.song().capture_midi())`,
            
            'new_audio_track': `
    def _setup_new_audio_track_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(lambda value: value and self.song().create_audio_track())`,
            
            'new_midi_track': `
    def _setup_new_midi_track_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(lambda value: value and self.song().create_midi_track())`,
            
            'duplicate': `
    def _setup_duplicate_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(self._duplicate_track)`,
            
            'delete': `
    def _setup_delete_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(self._delete_track)`,
            
            'next_scene': `
    def _setup_next_scene_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(self._next_scene)`,
            
            'previous_scene': `
    def _setup_previous_scene_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(self._previous_scene)`,
            
            'launch_selected_scene': `
    def _setup_launch_scene_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(lambda value: value and self.song().view.selected_scene.fire())`,
            
            'automation_arm': `
    def _setup_automation_arm_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        self._transport.set_automation_arm_button(button)`,
            
            'back_to_arrangement': `
    def _setup_back_to_arrangement_button(self, button_id):
        button = ButtonElement(True, MIDI_NOTE_TYPE, 0, button_id)
        button.add_value_listener(lambda value: value and self.song().back_to_arranger and self.song().back_to_arranger())`,
        };

        // Créer les appels de setup pour chaque bouton configuré
        let buttonSetups = '';
        for (const [buttonId, command] of Object.entries(config.buttons)) {
            if (command && buttonFunctions[command]) {
                buttonSetups += `\n        # Bouton ${buttonId} -> ${command}
        self._setup_${command}_button(${buttonId})`;
            }
        }

        // Créer les méthodes de setup
        let setupMethods = '';
        const usedCommands = new Set(Object.values(config.buttons));
        for (const command of usedCommands) {
            if (command && buttonFunctions[command]) {
                setupMethods += buttonFunctions[command] + '\n';
            }
        }

        return `# APC Mini MK1 Custom Script
# Generated by APC Mini Configurator
# Compatible with Ableton Live 10/11/12

import Live
from _Framework.ControlSurface import ControlSurface
from _Framework.InputControlElement import MIDI_NOTE_TYPE, MIDI_CC_TYPE
from _Framework.ButtonElement import ButtonElement
from _Framework.EncoderElement import EncoderElement
from _Framework.SessionComponent import SessionComponent
from _Framework.TransportComponent import TransportComponent
from _Framework.MixerComponent import MixerComponent

class APC_Mini_Custom(ControlSurface):
    """Custom APC Mini MK1 Control Surface Script"""
    
    def __init__(self, c_instance):
        super(APC_Mini_Custom, self).__init__(c_instance)
        self._c_instance = c_instance
        
        with self.component_guard():
            self._setup_transport()
            self._setup_mixer()
            self._setup_session()
            self._setup_custom_buttons()
            
        self.log_message("APC Mini Custom script loaded successfully")
    
    def _setup_transport(self):
        """Configuration du transport"""
        self._transport = TransportComponent()
    
    def _setup_mixer(self):
        """Configuration du mixer"""
        self._mixer = MixerComponent(8)
        
        # Faders (48-56)
        for i in range(8):
            strip = self._mixer.channel_strip(i)
            fader = EncoderElement(MIDI_CC_TYPE, 0, 48 + i, Live.MidiMap.MapMode.absolute)
            strip.set_volume_control(fader)
        
        # Track select buttons (64-71)
        for i in range(8):
            button = ButtonElement(True, MIDI_NOTE_TYPE, 0, 64 + i)
            self._mixer.channel_strip(i).set_select_button(button)
    
    def _setup_session(self):
        """Configuration de la session pour les pads"""
        self._session = SessionComponent(8, 8)
        self._session.set_offsets(0, 0)
        
        # Configuration des pads (0-63)
        for row in range(8):
            for col in range(8):
                pad_index = row * 8 + col
                note = (7 - row) * 8 + col  # Mapping APC Mini
                
                button = ButtonElement(True, MIDI_NOTE_TYPE, 0, note)
                button.set_on_off_values(1, 0)  # Vert quand actif
                
                # Assigner le pad
                self._session.scene(row).clip_slot(col).set_launch_button(button)
    
    def _setup_custom_buttons(self):
        """Configuration des boutons personnalisés 82-88"""${buttonSetups}
${setupMethods}
    
    # Fonctions helper
    def _duplicate_track(self, value):
        if value:
            track_index = list(self.song().tracks).index(self.song().view.selected_track)
            self.song().duplicate_track(track_index)
    
    def _delete_track(self, value):
        if value:
            track_index = list(self.song().tracks).index(self.song().view.selected_track)
            self.song().delete_track(track_index)
    
    def _next_scene(self, value):
        if value:
            scene = self.song().view.selected_scene
            scenes = list(self.song().scenes)
            index = scenes.index(scene)
            if index < len(scenes) - 1:
                self.song().view.selected_scene = scenes[index + 1]
    
    def _previous_scene(self, value):
        if value:
            scene = self.song().view.selected_scene
            scenes = list(self.song().scenes)
            index = scenes.index(scene)
            if index > 0:
                self.song().view.selected_scene = scenes[index - 1]
    
    def disconnect(self):
        """Nettoyage à la déconnexion"""
        self.log_message("Disconnecting APC Mini Custom")
        super(APC_Mini_Custom, self).disconnect()
`;
    },
    
    // Générer le README
    generateReadme() {
        return `APC Mini MK1 Custom Script pour Ableton Live
==========================================

INSTALLATION
------------
1. Décompressez ce dossier
2. Copiez le dossier "APC_Mini_Custom" dans :
   
   Windows:
   C:\\ProgramData\\Ableton\\Live [version]\\Resources\\MIDI Remote Scripts\\
   
   Mac:
   /Applications/Ableton Live [version].app/Contents/App-Resources/MIDI Remote Scripts/
   
   Ou dans votre dossier User Library :
   ~/Music/Ableton/User Library/Remote Scripts/

3. Redémarrez Ableton Live

4. Dans Préférences > Link/MIDI :
   - Surface de contrôle : APC_Mini_Custom
   - Entrée : APC MINI
   - Sortie : APC MINI

UTILISATION
-----------
- Les pads 0-63 contrôlent les clips de session (8x8)
- Les faders 48-56 contrôlent le volume des pistes 1-8
- Les boutons 64-71 sélectionnent les pistes
- Les boutons 82-88 sont configurés selon vos préférences
- Le bouton 89 est le modificateur Shift

CONFIGURATION
-------------
Pour modifier la configuration, utilisez l'interface web du configurateur
et générez un nouveau package.

Support : https://github.com/votre-repo/apc-mini-custom

Bon mix !
`;
    },
    
    // Générer le guide de mapping
    generateMappingGuide(config) {
        let buttonMapping = 'CONFIGURATION DES BOUTONS 82-88\n';
        buttonMapping += '================================\n\n';
        
        for (const [buttonId, command] of Object.entries(config.buttons)) {
            if (command) {
                const label = Buttons.getCommandLabel(command);
                buttonMapping += `Bouton ${buttonId} : ${label}\n`;
            } else {
                buttonMapping += `Bouton ${buttonId} : Non assigné\n`;
            }
        }
        
        buttonMapping += `Bouton 89 : Shift (fixe)\n`;
        
        return `GUIDE DE MAPPING APC MINI MK1
==============================

${buttonMapping}

MAPPING DES PADS DANS ABLETON
=============================

Les pads 0-63 sont automatiquement mappés à la grille de session 8x8.
Pour mapper des fonctions supplémentaires :

1. Entrez en mode MIDI Map (CMD+M sur Mac, CTRL+M sur Windows)
2. Cliquez sur le paramètre à contrôler dans Ableton
3. Appuyez sur le pad correspondant sur votre APC Mini
4. Sortez du mode MIDI Map

ORGANISATION DES PADS
=====================

   [56][57][58][59][60][61][62][63]  <- Ligne 8
   [48][49][50][51][52][53][54][55]  <- Ligne 7
   [40][41][42][43][44][45][46][47]  <- Ligne 6
   [32][33][34][35][36][37][38][39]  <- Ligne 5
   [24][25][26][27][28][29][30][31]  <- Ligne 4
   [16][17][18][19][20][21][22][23]  <- Ligne 3
   [ 8][ 9][10][11][12][13][14][15]  <- Ligne 2
   [ 0][ 1][ 2][ 3][ 4][ 5][ 6][ 7]  <- Ligne 1

FADERS (MIDI CC)
================
Fader 1: CC 48 (Canal 1)
Fader 2: CC 49 (Canal 2)
Fader 3: CC 50 (Canal 3)
Fader 4: CC 51 (Canal 4)
Fader 5: CC 52 (Canal 5)
Fader 6: CC 53 (Canal 6)
Fader 7: CC 54 (Canal 7)
Fader 8: CC 55 (Canal 8)
Fader Master: CC 56

BOUTONS DE SELECTION DE PISTE
==============================
Bouton 64: Sélection piste 1
Bouton 65: Sélection piste 2
Bouton 66: Sélection piste 3
Bouton 67: Sélection piste 4
Bouton 68: Sélection piste 5
Bouton 69: Sélection piste 6
Bouton 70: Sélection piste 7
Bouton 71: Sélection piste 8

ASTUCES
=======
- Le script active automatiquement le feedback LED
- Les pads s'allument en vert quand un clip est présent
- Les LEDs suivent l'état des clips (lecture, enregistrement, etc.)
- Utilisez le bouton Shift (89) pour accéder aux fonctions secondaires

Bon mapping !
`;
    },
    
    // Télécharger un fichier
    downloadFile(content, filename) {
        const a = document.createElement('a');
        const url = URL.createObjectURL(content);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }
};

// Charger JSZip depuis CDN si pas déjà chargé
if (typeof JSZip === 'undefined') {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
    script.onload = () => {
        App.log('JSZip chargé', 'info');
    };
    document.head.appendChild(script);
}